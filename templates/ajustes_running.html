<!DOCTYPE html>   
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ajustes de Ritmo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Fuente Poppins -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    /* Estilos resumidos */
    * {
      box-sizing: border-box;
      font-family: 'Poppins', sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      text-align: center;
    }
    .logo {
      width: 200px;
      margin: 20px 0;
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .logo:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 15px rgba(255, 204, 0, 0.7);
    }
    /* Contenedor principal: ahora con max-width: 800px */
    .container {
      position: relative;
      width: 90%;
      max-width: 800px;
      background: linear-gradient(145deg, #222, #111);
      text-align: center;
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0px 4px 20px rgba(255, 204, 0, 0.3);
      border: 2px solid #ffcc00;
      margin-bottom: 20px;
    }
    h1 {
      color: #ffcc00;
      font-size: 1.8rem;
      font-weight: 600;
      margin-bottom: 20px;
    }
    label {
      color: #bbb;
      font-weight: 600;
      display: block;
      margin-top: 10px;
      margin-bottom: 5px;
      text-align: center;
    }
    select, input[type="text"] {
      width: 80%;
      padding: 8px;
      border-radius: 10px;
      border: none;
      background: #1a1a1a;
      color: #fff;
      box-shadow: inset 4px 4px 8px rgba(0,0,0,0.5),
                  inset -4px -4px 8px rgba(255,255,255,0.1);
      text-align: center;
      outline: none;
      margin-bottom: 10px;
    }
    select:focus, input[type="text"]:focus {
      border: 1px solid #ffd966;
      box-shadow: 0 0 8px rgba(255,204,0,0.5);
    }
    /* ============================
       Estilos del Slider (actualizados)
    ============================ */
    #sliderValue {
      color: #ffcc00;
      font-weight: 600;
      margin-bottom: 5px;
      display: block;
      text-align: center;
      font-size: 1em;
    }
    #timeSlider,
    #distanceSlider,
    #elevationSlider {
      -webkit-appearance: none;
      width: 80%;
      background: transparent;
      margin: 10px 0;
      cursor: pointer;
    }
    /* Track para WebKit */
    #timeSlider::-webkit-slider-runnable-track,
    #distanceSlider::-webkit-slider-runnable-track,
    #elevationSlider::-webkit-slider-runnable-track {
      height: 8px;
      background: #ffcc00;
      border-radius: 5px;
    }
    /* Thumb para WebKit */
    #timeSlider::-webkit-slider-thumb,
    #distanceSlider::-webkit-slider-thumb,
    #elevationSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 20px;
      width: 20px;
      background: #4f4108;
      border: 2px solid #ffe066;
      border-radius: 50%;
      margin-top: -6px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.3s;
    }
    #timeSlider::-webkit-slider-thumb:hover,
    #distanceSlider::-webkit-slider-thumb:hover,
    #elevationSlider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 6px 12px rgba(0,0,0,0.6),
                  inset 0 -6px 12px rgba(255,255,255,0.5);
    }
    /* Track para Firefox */
    #timeSlider::-moz-range-track,
    #distanceSlider::-moz-range-track,
    #elevationSlider::-moz-range-track {
      height: 8px;
      background: #ffcc00;
      border-radius: 5px;
    }
    /* Thumb para Firefox */
    #timeSlider::-moz-range-thumb,
    #distanceSlider::-moz-range-thumb,
    #elevationSlider::-moz-range-thumb {
      height: 20px;
      width: 20px;
      background: #ffcc00;
      border: 2px solid #ffe066;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.3s;
    }
    #timeSlider::-moz-range-thumb:hover,
    #distanceSlider::-moz-range-thumb:hover,
    #elevationSlider::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 6px 12px rgba(0,0,0,0.6),
                  inset 0 -6px 12px rgba(255,255,255,0.5);
    }
    /* Estilos para IE y Edge */
    #timeSlider::-ms-track,
    #distanceSlider::-ms-track,
    #elevationSlider::-ms-track {
      height: 8px;
      background: transparent;
      border-color: transparent;
      color: transparent;
    }
    #timeSlider::-ms-fill-lower,
    #distanceSlider::-ms-fill-lower,
    #elevationSlider::-ms-fill-lower {
      background: #ffcc00;
      border-radius: 5px;
    }
    #timeSlider::-ms-fill-upper,
    #distanceSlider::-ms-fill-upper,
    #elevationSlider::-ms-fill-upper {
      background: #ffcc00;
      border-radius: 5px;
    }
    #timeSlider::-ms-thumb,
    #distanceSlider::-ms-thumb,
    #elevationSlider::-ms-thumb {
      height: 20px;
      width: 20px;
      background: #ffcc00;
      border: 2px solid #ffe066;
      border-radius: 50%;
      cursor: pointer;
    }
    /* ============================
       Estilos de Botones
    ============================ */
    .button-primary, .back-link {
      display: inline-block;
      padding: 12px 24px;
      background: linear-gradient(135deg, #ffcc00, #e6b800);
      color: #000;
      font-weight: bold;
      border: none;
      border-radius: 10px;
      text-decoration: none;
      box-shadow: 0 4px 10px rgba(255,204,0,0.5);
      transition: all 0.3s ease-in-out;
      cursor: pointer;
      font-size: 1rem;
      margin-top: 15px;
    }
    .button-primary:hover, .back-link:hover {
      background: linear-gradient(135deg, #ffd966, #e6c300);
      box-shadow: 0 8px 15px rgba(255,204,0,0.7);
      transform: translateY(-2px);
    }
    .back-link {
      background: none;
      color: #ffcc00;
      box-shadow: none;
      font-size: 1em;
      padding: 10px 20px;
    }
    /* ============================
       Estilos para la Tabla de Resultados (estilo móvil)
    ============================ */
    table {
      width: 100%;
      margin: 20px 0;
      border-collapse: collapse;
      background: #1a1a1a;
      box-shadow: 0px 4px 10px rgba(255,204,0,0.2);
      border-radius: 10px;
      overflow: hidden;
    }
    table th, table td {
      padding: 15px;
      text-align: center;
      border-bottom: 1px solid #333;
    }
    table th {
      background-color: #ffcc00;
      color: #000;
      font-weight: 600;
    }
    table tr:hover {
      background-color: #2a2a2a;
      transition: background-color 0.3s ease;
    }
    table tbody tr:last-child td {
      border-bottom: none;
    }
    /* ============================
       Otros estilos (ayuda, imagen, etc.)
    ============================ */
    .strategy-label {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      color: #bbb;
      font-weight: 600;
      margin-bottom: 5px;
    }
    .help-icon {
      width: 24px; 
      height: 24px;
      background: #ffcc00;
      color: #000;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    }
    .help-text {
      display: none;
      background: #1a1a1a;
      border: 1px solid #ffcc00;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(255,204,0,0.3);
      text-align: left;
      margin: 10px 0;
      font-size: 0.9rem;
    }
    /* ============================
       Estilos para la Tabla km a km (estilo móvil)
    ============================ */
    .km-table {
      width: 100%;
      border-collapse: collapse;
      background: #1a1a1a;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(255,204,0,0.2);
    }
    .km-table thead {
      background-color: #ffcc00;
      color: #000;
    }
    .km-table th, .km-table td {
      text-align: center;
      padding: 10px;
      border-bottom: 1px solid #333;
    }
    .km-table tbody tr:last-child td {
      border-bottom: none;
    }
    .km-table tr:hover {
      background-color: #2a2a2a;
      transition: background-color 0.3s;
    }
    @media (max-width: 600px) {
      .container {
        padding: 20px;
      }
      h1 {
        font-size: 1.8rem;
      }
      .button-primary, .back-link {
        width: 100%;
        padding: 10px 20px;
        font-size: 0.9rem;
      }
      .help-text {
        width: 200px;
        margin-left: -100px;
      }
    }
    /* Ajustes para la imagen dentro del contenedor */
    .highlight-image {
      margin: 20px 0;
      max-width: 100%;
      width: auto;
      height: auto;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(255,204,0,0.5);
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .highlight-image:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 15px rgba(255,204,0,0.7);
    }
  </style>
</head>
<body>
  <!-- Logo -->
  <img src="/static/logo fondo negro.png" alt="Logo" class="logo">
  <div class="container">
    <h1>Estrategia de Ritmo</h1>

    <!-- Inyectar datos -->
    <script>
      const estimatedTimes = {{ estimated_times|tojson }};
      console.log("Datos traídos de results:", estimatedTimes);
    </script>

    <!-- SELECCIÓN DE DISTANCIA: PRESET y/O PERSONALIZADA -->
    <div id="distanceSelection">
      <!-- Contenedor del desplegable (predefinido) -->
      <div id="presetDistanceContainer">
        <label for="selectDistance">Distancia (Preset):</label>
        <select id="selectDistance" onchange="syncDistanceSlider(); fillTime(); updateAll()">
          {% for dist, data in estimated_times.items() %}
          <option value="{{ dist }}">{{ dist }} km</option>
          {% endfor %}
        </select>
      </div>
      <!-- Opción para usar distancia personalizada -->
      <div>
        <label>
          <input type="checkbox" id="toggleCustomDistance" onchange="toggleDistanceInput(); updateAll()">
          Usar distancia personalizada
        </label>
      </div>
      <!-- Contenedor del slider de distancia personalizada -->
      <div id="customDistanceContainer" style="display:none;">
        <label for="distanceSlider">Distancia (km): <span id="distanceValue">5</span> km</label>
        <input
          type="range"
          id="distanceSlider"
          min="0"
          max="50"
          step="1"
          value="5"
          oninput="updateDistanceSlider(); updateAll()"
        >
      </div>
    </div>

    <!-- Tiempo final base (mostrar como texto, no input) -->
    <label>Tiempo final (HH:MM:SS):</label>
    <p id="inputTime" style="font-size:1.2rem; margin-bottom: 10px;">00:16:00</p>

    <!-- Estrategia -->
    <div class="strategy-label">
      <label for="selectStrategy">Estrategias de Ritmo:</label>
      <div class="help-icon" onclick="toggleHelpText()">?</div>
    </div>
    <div id="helpText" class="help-text">
      <p><strong>Estrategia Negativa (-1%, -2%, -3%):</strong><br>
         Comenzar más lento que el ritmo objetivo y terminar más rápido.</p>
      <p><strong>Estrategia Positiva (+1%, +2%, +3%):</strong><br>
         Comenzar más rápido y terminar más lento.</p>
      <p><strong>Estrategia Neutra:</strong><br>
         Ritmo constante en toda la prueba.</p>
    </div>
    <select id="selectStrategy" onchange="updateAll()">
      <option value="estable">Ritmo Estable</option>
      <option value="pos1">1% Positiva</option>
      <option value="pos2">2% Positiva</option>
      <option value="pos3">3% Positiva</option>
      <option value="neg1">1% Negativa</option>
      <option value="neg2">2% Negativa</option>
      <option value="neg3">3% Negativa</option>
    </select>

    <!-- Porcentaje del slider de ajuste de tiempo (±10%) -->
    <label for="timeSlider">Ajuste del tiempo (±10%):</label>
    <span id="sliderValue">0%</span>
    <input
      type="range"
      id="timeSlider"
      min="0.9"
      max="1.1"
      step="0.01"
      value="1.0"
      oninput="updateAll()"
    >

    <!-- Slider para Desnivel Acumulado (0 a 1000 m) -->
    <label for="elevationSlider">Desnivel Acumulado (m): <span id="elevationValue">0</span> m</label>
    <input
      type="range"
      id="elevationSlider"
      min="0"
      max="1000"
      step="1"
      value="0"
      oninput="updateElevation()"
    >

    <!-- Tabla principal (Base/Ajustado) -->
    <table>
      <tbody>
        <tr>
          <td><strong>Tiempo Final Base:</strong></td>
          <td id="baseTime">--:--:--</td>
        </tr>
        <tr>
          <td><strong>Ritmo Base (mm:ss/km):</strong></td>
          <td id="basePace">--:--</td>
        </tr>
        <tr>
          <td><strong>Tiempo Final Ajustado:</strong></td>
          <td id="adjustedTime">--:--:--</td>
        </tr>
        <tr>
          <td><strong>Ritmo Ajustado (mm:ss/km):</strong></td>
          <td id="adjustedPace">--:--</td>
        </tr>
      </tbody>
    </table>

    <!-- Imagen dentro del contenedor -->
    <a href="https://dzerotri.com/triatletas-dzero" target="_blank">
      <img src="/static/testimonios.png" alt="testimonios" class="highlight-image">
    </a>

    <!-- Tabla km a km -->
    <table class="km-table" id="kmTable">
      <thead>
        <tr>
          <th>KM</th>
          <th>Tiempo Base</th>
          <th>Ritmo Base</th>
          <th>Tiempo Ajustado</th>
          <th>Ritmo Ajustado</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div style="text-align:center;">
    <a href="/" class="button-primary">CONTINUAR</a>
  </div>

  <!-- Botón Volver a Resultados -->
  <div style="text-align:center; margin-top: 15px;">
    <a href="{{ url_for('running') }}" class="button-primary">Volver a Calcular</a>
  </div>

  <script>
    // Evitar scroll al mover slider en móvil
    const timeSlider = document.getElementById("timeSlider");
    timeSlider.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

    function toggleHelpText() {
      const help = document.getElementById("helpText");
      help.style.display = (help.style.display === "block") ? "none" : "block";
    }

    // Función que devuelve el factor de ajuste interpolado según la distancia.
    // Los valores predefinidos son:
    //   5 km: 1.07, 10 km: 1.07, 15 km: 1.06, 21.095 km: 1.06, 42.195 km: 1.06.
    function getAdjustmentFactor(distance) {
      const thresholds = [
        { dist: 5, factor: 1.07 },
        { dist: 10, factor: 1.07 },
        { dist: 15, factor: 1.06 },
        { dist: 21.095, factor: 1.06 },
        { dist: 42.195, factor: 1.06 }
      ];
      
      if (distance <= thresholds[0].dist) return thresholds[0].factor;
      for (let i = 1; i < thresholds.length; i++) {
        if (distance <= thresholds[i].dist) {
          const d0 = thresholds[i - 1].dist, f0 = thresholds[i - 1].factor;
          const d1 = thresholds[i].dist, f1 = thresholds[i].factor;
          if (d1 === d0) return f0;
          const t = (distance - d0) / (d1 - d0);
          return f0 + t * (f1 - f0);
        }
      }
      return thresholds[thresholds.length - 1].factor;
    }

    // La función fillTime() comprueba si la distancia seleccionada con el slider
    // está (dentro de una tolerancia de 0.5 km) cerca de un valor predefinido.
    // Si es así, se usa el tiempo de estimatedTimes para ese valor; de lo contrario,
    // se calcula el tiempo estimado a partir de la referencia para 5 km, escalado por la distancia y el factor de ajuste.
    function fillTime() {
      if (document.getElementById("toggleCustomDistance").checked) {
        const distance = parseFloat(document.getElementById("distanceSlider").value);
        const predefined = [5, 10, 15, 21.095, 42.195];
        let found = false;
        // Usamos una tolerancia de 0.5 km para coincidir con los valores predefinidos
        for (let i = 0; i < predefined.length; i++) {
          if (Math.abs(distance - predefined[i]) < 0.5) {
            if (estimatedTimes[predefined[i].toString()]) {
              document.getElementById("inputTime").textContent = estimatedTimes[predefined[i].toString()].time;
            }
            found = true;
            break;
          }
        }
        if (!found) {
          // Si no coincide, se calcula el tiempo estimado.
          const refTime = estimatedTimes["5"] ? estimatedTimes["5"].time : "00:16:00";
          const refSec = timeToSeconds(refTime);
          const basePaceSec = refSec / 5; // ritmo base en segundos/km (referencia para 5 km)
          const adjustment = getAdjustmentFactor(distance);
          const customTimeSec = basePaceSec * distance * adjustment;
          document.getElementById("inputTime").textContent = secondsToHMS(customTimeSec);
        }
      } else {
        const dist = document.getElementById("selectDistance").value;
        if (estimatedTimes[dist]) {
          document.getElementById("inputTime").textContent = estimatedTimes[dist].time;
        }
      }
    }

    function timeToSeconds(hms) {
      const parts = hms.split(":");
      const hours = parseInt(parts[0]);
      const minutes = parseInt(parts[1]);
      const seconds = parseInt(parts[2]);
      return hours * 3600 + minutes * 60 + seconds;
    }
    function secondsToHMS(sec) {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.floor(sec % 60);
      return String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
    }
    function secondsToPaceString(sec) {
      const minutes = Math.floor(sec / 60);
      const secs = Math.floor(sec % 60);
      return String(minutes).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
    }

    // Actualiza el valor mostrado del slider de ajuste de tiempo (±10%)
    function updateSliderValue() {
      const factor = parseFloat(document.getElementById("timeSlider").value);
      const diff = Math.round((factor - 1) * 100);
      let display = "";
      if (diff > 0) {
        display = "+" + diff + "%";
      } else if (diff < 0) {
        display = diff + "%";
      } else {
        display = "0%";
      }
      document.getElementById("sliderValue").textContent = display;
    }

    // Actualiza todos los cálculos y la tabla (tiempo final, ritmo base, etc.)
    function updateAll() {
      fillTime();
      updateSliderValue();
      let distance;
      if (document.getElementById("toggleCustomDistance").checked) {
        distance = parseFloat(document.getElementById("distanceSlider").value);
      } else {
        distance = parseFloat(document.getElementById("selectDistance").value);
      }
      // Se utiliza la distancia seleccionada para calcular ritmos
      const userTime = document.getElementById("inputTime").textContent || "00:16:00";
      const userTimeSec = timeToSeconds(userTime);
      const basePaceSec = userTimeSec / distance;
      document.getElementById("baseTime").textContent = userTime;
      document.getElementById("basePace").textContent = secondsToPaceString(basePaceSec);
      const factor = parseFloat(document.getElementById("timeSlider").value);
      const strategy = document.getElementById("selectStrategy").value;
      const totalAdjustedSec = calcTotalSeconds(distance, basePaceSec, strategy, factor);
      document.getElementById("adjustedTime").textContent = secondsToHMS(Math.round(totalAdjustedSec));
      document.getElementById("adjustedPace").textContent = secondsToPaceString(totalAdjustedSec / distance);
      
      const baseSplits = buildKmSplits(distance, basePaceSec, strategy, factor, true);
      const adjSplits = buildKmSplits(distance, basePaceSec, strategy, factor, false);
      const tbody = document.getElementById("kmTable").querySelector("tbody");
      tbody.innerHTML = "";
      const maxLen = Math.max(baseSplits.length, adjSplits.length);
      for (let i = 0; i < maxLen; i++) {
        const b = baseSplits[i];
        const a = adjSplits[i];
        const kmLabel = b ? b.kmDisplay : (a ? a.kmDisplay : "");
        const baseTimeAcc = b ? b.accumulated : "";
        const basePace = b ? b.paceString : "";
        const adjTimeAcc = a ? a.accumulated : "";
        const adjPace = a ? a.paceString : "";
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${kmLabel}</td>
          <td>${baseTimeAcc}</td>
          <td>${basePace}</td>
          <td>${adjTimeAcc}</td>
          <td>${adjPace}</td>
        `;
        tbody.appendChild(row);
      }
    }

    // Funciones de splits y cálculo (sin cambios)
    function getSplitFactor(km, totalKm, strategy) {
      let ratio = 0;
      if (strategy === "pos1") ratio = +0.01;
      if (strategy === "pos2") ratio = +0.02;
      if (strategy === "pos3") ratio = +0.03;
      if (strategy === "neg1") ratio = -0.01;
      if (strategy === "neg2") ratio = -0.02;
      if (strategy === "neg3") ratio = -0.03;
      if (strategy === "estable") {
        return 1.0;
      }
      const quarter = totalKm / 4.0;
      let phaseAdjustments = [1, 1, 1, 1];
      if (strategy.startsWith("pos")) {
        const absR = Math.abs(ratio);
        phaseAdjustments = [
          1.0 - absR * 0.5,
          1.0 - absR * 0.2,
          1.0 + absR * 0.2,
          1.0 + absR * 0.5
        ];
      } else if (strategy.startsWith("neg")) {
        const absR = Math.abs(ratio);
        phaseAdjustments = [
          1.0 + absR * 0.5,
          1.0 + absR * 0.2,
          1.0 - absR * 0.2,
          1.0 - absR * 0.5
        ];
      }
      if (km > 3 * quarter) return phaseAdjustments[3];
      else if (km > 2 * quarter) return phaseAdjustments[2];
      else if (km > quarter) return phaseAdjustments[1];
      else return phaseAdjustments[0];
    }

    function calcTotalSeconds(distance, basePaceSec, strategy, factor) {
      const fullKm = Math.floor(distance);
      const leftover = distance - fullKm;
      let totalSec = 0;
      for (let km = 1; km <= fullKm; km++) {
        const splitF = getSplitFactor(km, distance, strategy);
        totalSec += (basePaceSec * factor) * splitF;
      }
      if (leftover > 0) {
        const partialIndex = fullKm + leftover;
        const splitF = getSplitFactor(partialIndex, distance, strategy);
        totalSec += (basePaceSec * factor) * splitF * leftover;
      }
      return totalSec;
    }

    function buildKmSplits(distance, basePaceSec, strategy, factor, isBase = false) {
      let results = [];
      let accumulated = 0;
      const fullKm = Math.floor(distance);
      const leftover = distance - fullKm;
      for (let km = 1; km <= fullKm; km++) {
        const sFactor = isBase 
          ? getSplitFactor(km, distance, "estable") 
          : getSplitFactor(km, distance, strategy);
        const paceSec = (basePaceSec * (isBase ? 1 : factor)) * sFactor;
        accumulated += paceSec;
        results.push({
          kmDisplay: km.toString(),
          accumulated: secondsToHMS(Math.round(accumulated)),
          paceString: secondsToPaceString(paceSec)
        });
      }
      if (leftover > 0) {
        const partialIndex = fullKm + leftover;
        const sFactor = isBase
          ? getSplitFactor(partialIndex, distance, "estable")
          : getSplitFactor(partialIndex, distance, strategy);
        const paceSec = (basePaceSec * (isBase ? 1 : factor)) * sFactor * leftover;
        accumulated += paceSec;
        results.push({
          kmDisplay: partialIndex.toFixed(3),
          accumulated: secondsToHMS(Math.round(accumulated)),
          paceString: secondsToPaceString((basePaceSec * (isBase ? 1 : factor)) * sFactor)
        });
      }
      return results;
    }

    // Funciones para el slider de distancia personalizada
    function toggleDistanceInput() {
      const custom = document.getElementById("toggleCustomDistance").checked;
      document.getElementById("customDistanceContainer").style.display = custom ? "block" : "none";
      document.getElementById("presetDistanceContainer").style.display = custom ? "none" : "block";
    }
    function updateDistanceSlider() {
      const val = document.getElementById("distanceSlider").value;
      document.getElementById("distanceValue").textContent = val;
    }
    function syncDistanceSlider() {
      const preset = document.getElementById("selectDistance").value;
      document.getElementById("distanceSlider").value = preset;
      document.getElementById("distanceValue").textContent = preset;
    }

    // Función para actualizar el slider de desnivel
    function updateElevation() {
      const elev = document.getElementById("elevationSlider").value;
      document.getElementById("elevationValue").textContent = elev;
    }

    window.onload = () => {
      updateAll();
    };
  </script>
</body>
</html>
